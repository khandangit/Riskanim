<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Interactive Risk Pathway — Entry → Exposure → Establishment → Overall</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    :root { --ui-gap: 10px; }
    body { margin:0; padding:0; display:flex; flex-direction:column; align-items:center; font-family: system-ui, Arial, sans-serif; background:#f6f7f9; }
    #ui {
      display:grid; grid-template-columns: repeat(12, auto); gap: var(--ui-gap); align-items:center;
      padding:12px; margin:12px; background:#fff; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,.08);
    }
    #ui > * { margin:0; }
    label { font-size:12px; color:#333; }
    select, input[type="range"] { padding:4px 6px; border:1px solid #ddd; border-radius:8px; }
    button { padding:6px 10px; border-radius:8px; border:1px solid #ddd; background:#fafafa; cursor:pointer; }
    button:hover { background:#f0f0f0; }
    #playBtn { background:#4caf50; color:white; border-color:#43a047; }
    #playBtn:hover { background:#43a047; }
    #recWebmBtn { background:#2962ff; color:#fff; border-color:#1e49c9; }
    #recWebmBtn:disabled { opacity:.55; }
    #status { font-size:12px; color:#444; padding:4px 8px; background:#f3f6ff; border:1px solid #d7e2ff; border-radius:8px; }
    canvas { display:block; background:#fff; border-radius:12px; box-shadow:0 10px 24px rgba(0,0,0,.12); }
    @media (max-width: 1100px) { #ui { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <div id="ui">
    <label>Shape</label>
    <select id="shapeSel">
      <option>Bug</option>
      <option>Virus</option>
      <option>Spore</option>
    </select>

    <label>Speed (faster → slower)</label>
    <input id="speed" type="range" min="30" max="200" step="5" value="110">

    <label>Min size</label>
    <input id="sizeMin" type="range" min="6" max="40" step="1" value="10">

    <label>Max size</label>
    <input id="sizeMax" type="range" min="30" max="90" step="1" value="56">

    <label>Entry</label>
    <select id="entrySel">
      <option>High</option>
      <option selected>Medium</option>
      <option>Low</option>
      <option>Negligible</option>
    </select>

    <label>Exposure</label>
    <select id="exposureSel">
      <option>High</option>
      <option>Medium</option>
      <option selected>Low</option>
      <option>Negligible</option>
    </select>

    <label>Establishment</label>
    <select id="estabSel">
      <option>High</option>
      <option selected>Medium</option>
      <option>Low</option>
      <option>Negligible</option>
    </select>

    <label>Economic consequence</label>
    <select id="econSel">
      <option>Extreme</option>
      <option>High</option>
      <option selected>Medium</option>
      <option>Low</option>
      <option>Very low</option>
      <option>Negligible</option>
    </select>

    <button id="playBtn">Play</button>
    <button id="pauseBtn">Pause</button>

    <button id="recWebmBtn" title="Record WebM">Record WebM</button>
    <button id="stopSaveBtn" disabled>Stop &amp; Save</button>

    <span id="status">Idle</span>
  </div>

  <script>
    // ========= Qualitative RULES =========
    // Table 4: combine two likelihoods
    const COMB2 = {
      "High":       {"High":"High","Medium":"Medium","Low":"Low","Negligible":"Negligible"},
      "Medium":     {"High":"Medium","Medium":"Low","Low":"Low","Negligible":"Negligible"},
      "Low":        {"High":"Low","Medium":"Low","Low":"Extremely low","Negligible":"Negligible"},
      "Negligible": {"High":"Negligible","Medium":"Negligible","Low":"Negligible","Negligible":"Negligible"}
    };
    function combine2(a,b){ return COMB2[a][b]; }
    // Entry → Exposure → Establishment
    function combine3(entry, exposure, establishment) {
      return combine2( combine2(entry, exposure), establishment );
    }

    // Table 6: econ consequence × combined likelihood
    const RISK_TBL = {
      "Extreme":   {"High":"Extreme risk","Medium":"Extreme risk","Low":"High risk","Extremely low":"Medium risk","Negligible":"Low risk"},
      "High":      {"High":"High risk","Medium":"High risk","Low":"Medium risk","Extremely low":"Low risk","Negligible":"Very low risk"},
      "Medium":    {"High":"Medium risk","Medium":"Medium risk","Low":"Low risk","Extremely low":"Very low risk","Negligible":"Negligible risk"},
      "Low":       {"High":"Low risk","Medium":"Low risk","Low":"Very low risk","Extremely low":"Negligible risk","Negligible":"Negligible risk"},
      "Very low":  {"High":"Very low risk","Medium":"Very low risk","Low":"Negligible risk","Extremely low":"Negligible risk","Negligible":"Negligible risk"},
      "Negligible":{"High":"Negligible risk","Medium":"Negligible risk","Low":"Negligible risk","Extremely low":"Negligible risk","Negligible":"Negligible risk"}
    };
    function overallRisk(econ, like){ return RISK_TBL[econ][like]; }

    // Map qualitative to scalar size factors
    const likeToScalar = lvl => ({
      "High": 1.00, "Medium": 0.75, "Low": 0.45, "Extremely low": 0.30, "Negligible": 0.20
    })[lvl];

    const riskToScalar = risk => ({
      "Extreme risk":1.00,"High risk":0.90,"Medium risk":0.75,"Low risk":0.55,"Very low risk":0.40,"Negligible risk":0.25
    })[risk];

    // ========= p5 sketch & Recording =========
    const CAN_W = 1100, CAN_H = 420;
    const PADDING_X = 120;
    const X0 = PADDING_X, X4 = CAN_W - PADDING_X;
    const X1 = X0 + (X4 - X0) * 0.25;
    const X2 = X0 + (X4 - X0) * 0.50;
    const X3 = X0 + (X4 - X0) * 0.75;
    const Y  = CAN_H/2 + 10;

    // UI refs
    let shapeSel, speedSlider, sMinSlider, sMaxSlider;
    let entrySel, exposureSel, estabSel, econSel;
    let playBtn, pauseBtn, statusEl, recWebmBtn, stopSaveBtn;

    // Animation state
    let t = 0;       // logical time 0..4
    let paused = false, finished = false;

    // Recording
    let canvasEl = null, capturing = false, mediaRecorder = null, webmChunks = [];

    function setup(){
      const cnv = createCanvas(CAN_W, CAN_H);
      cnv.parent(document.body);
      canvasEl = cnv.canvas;
      pixelDensity(1);
      noStroke();
      textFont('system-ui, Arial, sans-serif');
      textSize(12);

      // Wire UI
      shapeSel    = document.getElementById('shapeSel');
      speedSlider = document.getElementById('speed');
      sMinSlider  = document.getElementById('sizeMin');
      sMaxSlider  = document.getElementById('sizeMax');
      entrySel    = document.getElementById('entrySel');
      exposureSel = document.getElementById('exposureSel');
      estabSel    = document.getElementById('estabSel');
      econSel     = document.getElementById('econSel');
      playBtn     = document.getElementById('playBtn');
      pauseBtn    = document.getElementById('pauseBtn');
      statusEl    = document.getElementById('status');
      recWebmBtn  = document.getElementById('recWebmBtn');
      stopSaveBtn = document.getElementById('stopSaveBtn');

      playBtn.onclick = () => restart();
      pauseBtn.onclick = () => { if(!finished){ paused = !paused; setStatus(paused?'Paused':'Playing'); } };

      recWebmBtn.onclick = () => startRecordingWebM();
      stopSaveBtn.onclick = () => stopAndSaveRecording();

      setStatus('Idle');
    }

    function restart(){
      t = 0; paused = false; finished = false; setStatus('Playing'); loop();
    }
    function setStatus(msg){ statusEl.textContent = msg; }

    function startRecordingWebM(){
      if (capturing) return;
      restart(); // clean take
      const fps = 30;
      const stream = canvasEl.captureStream(fps);
      webmChunks = [];
      const opts = { mimeType: 'video/webm;codecs=vp9' };
      try { mediaRecorder = new MediaRecorder(stream, opts); }
      catch(e){ mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' }); }
      mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) webmChunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        const blob = new Blob(webmChunks, { type: 'video/webm' });
        await saveBlobWithDialog(blob, 'risk_pathway.webm', 'video/webm');
        setStatus('Saved WebM ✅'); mediaRecorder = null;
      };
      mediaRecorder.start();
      capturing = true; recWebmBtn.disabled = true; stopSaveBtn.disabled = false;
      setStatus('Recording WebM…');
    }

    async function stopAndSaveRecording(){
      if (!capturing) return;
      stopSaveBtn.disabled = true; setStatus('Finalising WebM…');
      if (mediaRecorder) mediaRecorder.stop();
      capturing = false; recWebmBtn.disabled = false; stopSaveBtn.disabled = true;
    }

    async function saveBlobWithDialog(blob, suggestedName, mime){
      if (window.showSaveFilePicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName,
            types: [{ description: 'WebM', accept: { [mime]: ['.webm'] } }]
          });
          const writable = await handle.createWritable();
          await writable.write(blob); await writable.close(); return;
        } catch(e) { /* fall through on cancel */ }
      }
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = suggestedName;
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 100);
    }

    function draw(){
      background(246);

      // Path line + ticks
      stroke(210); strokeWeight(2);
      line(X0, Y, X4, Y);
      const ticks = [X0, X1, X2, X3, X4];
      for (const x of ticks){ line(x, Y-8, x, Y+8); }
      noStroke();

      // Labels
      fill(40); textAlign(CENTER);
      text('Entry', X0, Y+28);
      text('Exposure', X1, Y+28);
      text('Establishment', X2, Y+28);
      text('Overall', X3, Y+28);

      // Selections
      const S_MIN = Number(sMinSlider.value), S_MAX = Number(sMaxSlider.value);
      const entryLike    = entrySel.value;
      const exposureLike = exposureSel.value;
      const estabLike    = estabSel.value;
      const combinedLike = combine3(entryLike, exposureLike, estabLike);
      const econ         = econSel.value;
      const risk         = overallRisk(econ, combinedLike);

      const sEntry   = lerp(S_MIN, S_MAX, likeToScalar(entryLike));
      const sExpos   = lerp(S_MIN, S_MAX, likeToScalar(exposureLike));
      const sEstab   = lerp(S_MIN, S_MAX, likeToScalar(estabLike));
      const sOverall = lerp(S_MIN, S_MAX, riskToScalar(risk));

      // Info text
      textAlign(LEFT);
      text(`Combined likelihood: ${combinedLike}`, X0, 36);
      text(`Overall risk (${econ} × ${combinedLike}): ${risk}`, X0, 54);

      // Time advance
      if(!paused && !finished){
        const speedDiv = Number(speedSlider.value); // larger = slower
        t += (1/speedDiv) * 6; // tune
        if (t >= 4){ t = 4; finished = true; if(!capturing) noLoop(); setStatus('Finished'); }
      }

      // Piecewise interpolate along phases
      let x, s;
      if (t <= 1){
        x = map(t, 0, 1, X0, X1);
        s = lerp(sEntry, sExpos, t);
      } else if (t <= 2){
        x = map(t, 1, 2, X1, X2);
        s = lerp(sExpos, sEstab, t-1);
      } else if (t <= 3){
        x = map(t, 2, 3, X2, X3);
        s = lerp(sEstab, sOverall, t-2);
      } else {
        x = map(t, 3, 4, X3, X4);
        s = sOverall;
      }

      // Colour by magnitude
      const col = colourForSize(s, S_MIN, S_MAX);
      fill(col.fill[0], col.fill[1], col.fill[2]);
      stroke(col.stroke[0], col.stroke[1], col.stroke[2]); strokeWeight(1.6);

      // Draw shape
      drawMarker(shapeSel.value, x, Y, s);

      // Node previews
      drawNodePreview(X0, Y, sEntry);
      drawNodePreview(X1, Y, sExpos);
      drawNodePreview(X2, Y, sEstab);
      drawNodePreview(X3, Y, sOverall);
    }

    function drawNodePreview(x,y,s){
      push(); noStroke(); fill(220); circle(x, y-26, clamp(s,8,18)); pop();
    }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function colourForSize(s, smin, smax){
      // map size to 0..1 then pick palette from blue→orange→red
      const u0 = (s - smin) / (smax - smin + 1e-6);
      let u = Math.max(0, Math.min(1, u0));
      const lerp3 = (a,b,t)=>Math.round(a+(b-a)*t);
      const c1 = {fill:[80,140,255], stroke:[40,90,210]};     // low
      const c2 = {fill:[255,165,60], stroke:[210,120,40]};     // medium
      const c3 = {fill:[235,87,87],  stroke:[200,60,60]};      // high
      let f, g;
      if (u < 0.5){ f=c1; g=c2; u = u/0.5; }
      else { f=c2; g=c3; u = (u-0.5)/0.5; }
      return {
        fill:   [lerp3(f.fill[0],g.fill[0],u), lerp3(f.fill[1],g.fill[1],u), lerp3(f.fill[2],g.fill[2],u)],
        stroke: [lerp3(f.stroke[0],g.stroke[0],u), lerp3(f.stroke[1],g.stroke[1],u), lerp3(f.stroke[2],g.stroke[2],u)]
      };
    }

    function drawMarker(type, x, y, s){
      push(); noStroke(); textAlign(CENTER, CENTER);
      switch(type){
        case "Bug":
          textSize(s*1.1); text('🪰', x, y + s*0.05); break;
        case "Virus":
          // simple vector "virus" look
          fill(255,255,255,70); stroke(0,0,0,40);
          for(let i=0;i<12;i++){
            const a = i * (Math.PI*2/12);
            line(x+Math.cos(a)*(s*0.55), y+Math.sin(a)*(s*0.55),
                 x+Math.cos(a)*(s*0.85), y+Math.sin(a)*(s*0.85));
          }
          noStroke(); fill(0,0,0,18); circle(x,y,s*0.95);
          fill(255); circle(x,y,s*0.65);
          fill(0,0,0,30); circle(x,y,s*0.35);
          break;
        case "Spore":
          circle(x, y, s, s);
          fill(255, 255, 255, 110);
          circle(x, y, s*0.38);
          break;
      }
      pop();
    }

    // Quick pause/resume on canvas tap
    function mousePressed(){
      if (mouseX>=0 && mouseX<=width && mouseY>=0 && mouseY<=height && !finished){
        paused = !paused; setStatus(paused?'Paused':'Playing');
      }
    }
  </script>
</body>
</html>
